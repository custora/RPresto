# Copyright (c) 2015-present, Facebook, Inc.
# All rights reserved.
#
# This source code is licensed under the BSD-style license found in the
# LICENSE file in the root directory of this source tree. An additional grant
# of patent rights can be found in the PATENTS file in the same directory.

#' @include extract.data.R json.tabular.to.data.frame.R
#' @include utility_functions.R PrestoResult.R
NULL

.fetch.uri.with.retries <- function(uri, num.retry=3) {
  get.response <- tryCatch({
      response <- httr::GET(uri)
      if (httr::status_code(response) >= 400L) {
        # stop_for_status also fails for 300 <= status < 400
        # so we need the if condition
        httr::stop_for_status(response)
      }
      response
    },
    error=function (e) {
      if (num.retry == 0) {
        stop("There was a problem with the request ",
         "and we have exhausted our retry limit for uri: ", uri)
      }
      message('GET call failed with error: "', conditionMessage(e),
              '", retrying [', 4 - num.retry, '/3]\n')
      wait()
      httr::handle_reset(uri)
      return(.fetch.uri.with.retries(uri, num.retry - 1))
    }
  )
  return(get.response)
}

.fetch.single.uri <- function(res, n, ...) {
  if (!dbIsValid(res)) {
    stop('Result object is not valid')
  }
  df <- data.frame()
  if (!res@cursor$hasCompleted()) {
    get.response <- .request.single.uri(res)
    df <- .process.single.uri(res, get.response)
  }
  return(df)
}

.request.single.uri <- function(res) {
  .trace('before request')
  get.response <- tryCatch(
    .fetch.uri.with.retries(res@cursor$nextUri()),
    error=function(e) {
      res@cursor$state('FAILED')
      stop(simpleError(
        paste0(
          'Cannot fetch ', res@cursor$nextUri(), ', ',
          'error: ', conditionMessage(e)
        ),
        call='.fetch.single.uri'
      ))
    }
  )

  check.status.code(get.response)
  .trace('after request')
  return(get.response)
}

.process.single.uri <- function(res, get.response) {
  .trace('before parse')
  content <- response.to.content(get.response)
  .trace('after parse')
  if (get.state(content) == 'FAILED') {
    res@cursor$state('FAILED')
    res@cursor$stats(content[['stats']])
    stop.with.error.message(content)
  }

  # Handle SET/RESET SESSION updates
  if (!is.null(content[['updateType']])) {
    switch(
      content[['updateType']],
      'SET SESSION' = {
        properties <- httr::headers(get.response)[['x-presto-set-session']]
        if (!is.null(properties)) {
          for (pair in strsplit(properties, ',', fixed = TRUE)) {
            pair <- unlist(strsplit(pair, '=', fixed = TRUE))
            res@session$setParameter(pair[1], pair[2])
          }
        }
      },
      'RESET SESSION' = {
        properties <- httr::headers(get.response)[['x-presto-clear-session']]
        if (!is.null(properties)) {
          for (key in strsplit(properties, ',', fixed = TRUE)) {
            res@session$unsetParameter(key)
          }
        }
      })
  }

  .trace('before extract')
  df <- .extract.data(content, timezone=res@session.timezone)
  .trace('after extract')
  .trace(paste0("df rows: ", NROW(df)))
  res@cursor$updateCursor(content, NROW(df))
  return(df)
}

.fetch.all <- function(result, requests.first=FALSE) {
  .trace('before main loop')
  rv <- list()
  chunk.count <- 1
  if (requests.first) {
    while (!dbHasCompleted(result)) {
      response <- .request.single.uri(result)
      rv[[chunk.count]] <- response
      chunk.count <- chunk.count + 1
      result@cursor$sniffNextUri(response)
    }

    for (i in 1:length(rv)) {
      rv[[i]] <- .process.single.uri(result, rv[[i]])
    }
  } else {
    while (!dbHasCompleted(result)) {
      chunk <- .fetch.single.uri(result)
      rv[[chunk.count]] <- chunk
      chunk.count <- chunk.count + 1
    }
  }

  .trace('after main loop')
  if (length(rv) == 1) {
    # Preserve attributes for empty data frames
    return(rv[[1]])
  } else {
    # We need to check for the uniqueness of columns because dplyr::bind_rows
    # will drop duplicate column names and we want to preserve all the data
    column.names <- names(rv[[1]])
    if (
      requireNamespace('dplyr', quietly=TRUE) &&
      length(column.names) == length(unique(column.names))
    ) {
      return(as.data.frame(dplyr::bind_rows(rv)))
    } else {
      return(do.call('rbind', rv))
    }
  }
}

.fetch.with.count <- function(res, n, requests.first=FALSE, ...) {
  if (!dbIsValid(res)) {
    stop('Result object is not valid')
  }
  if (!((n > 0 && is.infinite(n))
      || (as.integer(n) == -1L))) {
    stop('fetching custom number of rows (n != -1 and n != Inf) ',
         'is not supported, asking for: ', n)
  }
  return(.fetch.all(res, requests.first=requests.first))
}

#' @rdname PrestoResult-class
#' @export
setMethod('dbFetch', c('PrestoResult', 'integer'), .fetch.with.count)

#' @rdname PrestoResult-class
#' @export
setMethod('dbFetch', c('PrestoResult', 'numeric'), .fetch.with.count)

#' @rdname PrestoResult-class
#' @export
setMethod('dbFetch', c('PrestoResult', 'missing'), .fetch.single.uri)
